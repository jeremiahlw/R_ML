---
title: "Power Plants"
author: 'Jeremiah W'
date: "November 2020"
output:
  rmdformats::readthedown:
    code_folding: hide
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: tango
---

# MISC
```{r eval=FALSE}
# regarding 'readthedown' theme
# https://cran.r-project.org/web/packages/rmdformats/vignettes/introduction.html
```

```{r include=FALSE}
#https://datatables.net/reference/option/
options(DT.options = list(scrollX = TRUE, pagin=TRUE, fixedHeader = TRUE, searchHighlight = TRUE))

library(DataExplorer);library(data.table);library(dlookr);
library(extrafont);library(formattable);library(GGally);library(here);
library(janitor);library(lubridate);library(naniar);
library(patchwork);library(PerformanceAnalytics);
library(plotly);library(RColorBrewer);library(readxl);
library(skimr);library(tidyverse);library(scales)

library(caret);library(tidymodels);library(h2o)

library(rmdformats);library(tufte)
```


# Introduction

[Check out this Kaggle](https://www.kaggle.com/anikannal/solar-power-generation-data)

*This data has been gathered at two solar power plants in India over a 34 day period. It has two pairs of files - each pair has one power generation dataset and one sensor readings dataset. The power generation datasets are gathered at the inverter level - each inverter has multiple lines of solar panels attached to it. The sensor data is gathered at a plant level - single array of sensors optimally placed at the plant.*
 
There are a few areas of concern at the solar power plant -
 
1. Can we predict the power generation for next couple of days? - this allows for better grid management
2. Can we identify the need for panel cleaning/maintenance?
3. Can we identify faulty or sub-optimally performing equipment?

## Data Dictionary for Power Generation data sets

1. AC_POWER : Amount of AC power generated by the inverter (source_key) in this 15 minute interval. Units - kW.
2. AC_ : Amount of DC power generated by the inverter (source_key) in this 15 minute interval. Units - kW.
3. DAILY_YIELD : Daily yield is a cumulative sum of power generated on that day, till that point in time.
4. DATE_TIME : Date and time for each observation. Observations recorded at 15 minute intervals.
5. PLANT_ID : Plant ID - this will be common for the entire file.
6. SOURCE_KEY : Source key in this file stands for the inverter id.
7. TOTAL_YIELD : This is the total yield for the inverter till that point in time.

## Data Dictionary for Sensor Reading data sets

1. IRRADIATION: Amount of irradiation for the 15 minute interval.
2. DATE_TIME: Date and time for each observation. Observations recorded at 15 minute intervals.
3. PALNT_ID: Plant ID - this will be common for the entire file.
4. SOURCE_KEY: Stands for the sensor panel id. This will be common for the entire file because there's only one sensor panel for the plant.
5. MODULE_TEMPERATURE: There's a module (solar panel) attached to the sensor panel. This is the temperature reading for that module.
6. AMBIENT_TEMPERATURE: This is the ambient temperature at the plant.


# Power Generation data set: Plant 1

## Get and Split Data
```{r message=FALSE}

p1.gd = read_csv('Plant_1_Generation_Data.csv') %>%
  slice_sample(prop = 0.10) %>% #!!<NOTE>temp, working with a sample of datset for speed purposes
  clean_names() %>%  #lowercase
  select(sort(tidyselect::peek_vars())) %>% #sort cols alphabetically
  select(where(is.factor),where(is.character),where(is.numeric)) #sort cols by data type

#OlsonNames()
#https://stackoverflow.com/questions/41479008/what-is-the-correct-tz-database-time-zone-for-india

p1.gd = p1.gd %>% mutate(
  date_time = as.POSIXct(strptime(p1.gd$date_time, "%d-%m-%Y %H:%M"), tz = 'Asia/Kolkata'),
  source_key = factor(p1.gd$source_key),
  source_key = factor(p1.gd$source_key)
) %>% rename(inverter = source_key)

p1.gd$plant_id = NULL

```

### glimpse structure, and sample rows
```{r}
p1.gd %>% slice_sample(n = 10) %>% DT::datatable()
p1.gd %>% glimpse()
```

### check missing values
```{r}
p1.gd %>% miss_var_summary()
```

## EDA: Factor Vars

### counts each factor's unique levels
```{r}
sapply(p1.gd %>% select(where(is.factor)), n_unique) %>% as.data.frame()
```
### reference: names of unique levels
```{r}
sapply(p1.gd %>% select(where(is.factor)), unique) %>% as.data.frame() %>% arrange()
```

### viz: distribution of level counts
```{r fig.width=12, fig.height=9}
jpal = colorRampPalette(brewer.pal(8,'Dark2'))(22)

p1.gd %>% count(inverter) %>% plot_ly(y = ~fct_reorder(inverter,n), x = ~n, color = ~inverter, colors = jpal) %>% add_bars(hoverinfo = 'text', text = ~n) %>% hide_legend() %>% layout(
    title = 'Source Key Counts',
    xaxis = list(title = ''),
    yaxis = list(title = '')
    ) 
```

<h style="color: blue; font-size:12px;">Sanity Check - PASS - Pretty much a uniform distribution</h>

## EDA: Numeric Vars

### viz bivariate numeric distribution

```{r fig.width=12, fig.height=9}
DataExplorer::plot_boxplot(p1.gd %>% select(where(is.numeric)), by = 'daily_yield')
DataExplorer::plot_boxplot(p1.gd %>% select(where(is.numeric)), by = 'total_yield')
```

### viz: numeric univariate distributions
```{r fig.width=12, fig.height=9}
names.numeric = p1.gd %>% select(where(is.numeric)) %>% names

p1.gd %>% dlookr::plot_normality(
  names.numeric[1],
  names.numeric[2],
  names.numeric[3],
  names.numeric[4]
  )
```

<h style="color: red; font-size:12px;">Seems to be many outliers, especially 0s, in several features.  Indicative of faulty inverters?  Plot by inverter</h>

### viz: numeric univariate distributions
```{r fig.width=12, fig.height=9}
DataExplorer::plot_density(p1.gd %>% select(where(is.numeric)))
```

### viz: distributions by 'inverter' factor
```{r fig.width=12, fig.height=9}
p1.gd %>% mutate(inverter = fct_reorder(.f = inverter, .x = total_yield, .fun = median, .desc = TRUE)) %>%
  plot_ly(y = ~inverter, x = ~total_yield, color = ~inverter, colors = jpal) %>% add_boxplot()%>%
  hide_legend() %>% layout(xaxis = list(title = ''), yaxis = list(title = ''), title = 'Distribution of Total Yield by Inverter')

p1.gd %>% mutate(inverter = fct_reorder(.f = inverter, .x = daily_yield, .fun = median, .desc = TRUE)) %>%
  plot_ly(y = ~inverter, x = ~daily_yield, color = ~inverter, colors = jpal) %>% add_boxplot()%>%
  hide_legend() %>% layout(xaxis = list(title = ''), yaxis = list(title = ''), title = 'Distribution of Daily Yield by Inverter')

p1.gd %>% mutate(inverter = fct_reorder(.f = inverter, .x = ac_power, .fun = median, .desc = TRUE)) %>%
  plot_ly(y = ~inverter, x = ~ac_power, color = ~inverter, colors = jpal) %>% add_boxplot()%>%
  hide_legend() %>% layout(xaxis = list(title = ''), yaxis = list(title = ''), title = 'Distribution of AC Power by Inverter')

p1.gd %>% mutate(inverter = fct_reorder(.f = inverter, .x = dc_power, .fun = median, .desc = TRUE)) %>%
  plot_ly(y = ~inverter, x = ~dc_power, color = ~inverter, colors = jpal) %>% add_boxplot()%>%
  hide_legend() %>% layout(xaxis = list(title = ''), yaxis = list(title = ''), title = 'Distribution of DC Power by Inverter')
```

### correlations: viz
```{r fig.width=12, fig.height=9}
p1.gd %>% dlookr::plot_correlate()
```

<h style="color: blue; font-size:12px;">since dc and ac power are just perfectly convertible (like fahrenheit and celsius), they have a perfect correlation</h>

## EDA: Time Series Viz

## Anomoly Plot
```{r fig.width=15, fig.height= 12, warning=FALSE, message=FALSE}
library(scales)
library(anomalize)
# anomalize(data, target, method = c("iqr", "gesd"), alpha = 0.05, max_anoms = 0.2, verbose = FALSE)

# alpha: Controls the width of the "normal" range. Lower values are more conservative while higher values are less prone to incorrectly classifying "normal" observations.
# max_anoms: The maximum percent of anomalies permitted to be identified.

p1.gd.anomalize = p1.gd %>% arrange(date_time) %>% 
  mutate(inverter = fct_reorder(inverter, -daily_yield)) %>% 
  group_by(inverter) %>%
  time_decompose(daily_yield, method = 'twitter', merge = TRUE) %>%
  anomalize(remainder, alpha = 0.05, method = 'gesd') %>%
  time_recompose()

ggplotly(
  p1.gd.anomalize %>%
    plot_anomalies(
      ncol = 2,
      alpha_dots = 0.5,
      alpha_circles = 0.5,
      size_circles = 2,
      time_recomposed = TRUE,
      alpha_ribbon = 0.05
      ) + scale_y_continuous(labels = comma) +
    labs(x = '', y = 'daily yield')
  ) %>% layout(showlegend = FALSE)
```


# Power Generation data set: Plant 2

## Get and Split Data
```{r message=FALSE}

p2.gd = read_csv('Plant_2_Generation_Data.csv') %>%
  slice_sample(prop = 0.10) %>% #!!<NOTE>temp, working with a sample of datset for speed purposes
  clean_names() %>%  #lowercase
  select(sort(tidyselect::peek_vars())) %>% #sort cols alphabetically
  select(where(is.POSIXct), where(is.factor),where(is.character),where(is.numeric)) #sort cols by data type

#OlsonNames()
#https://stackoverflow.com/questions/41479008/what-is-the-correct-tz-database-time-zone-for-india

p2.gd = p2.gd %>% mutate(
  source_key = factor(p2.gd$source_key),
  source_key = factor(p2.gd$source_key)
) %>% rename(inverter = source_key)

p2.gd$plant_id = NULL

```

### glimpse structure, and sample rows
```{r}
p2.gd %>% slice_sample(n = 10) %>% DT::datatable()
p2.gd %>% glimpse()
```

### check missing values
```{r}
p2.gd %>% miss_var_summary()
```

## EDA: Factor Vars

### counts each factor's unique levels
```{r}
sapply(p2.gd %>% select(where(is.factor)), n_unique) %>% as.data.frame()
```
### reference: names of unique levels
```{r}
sapply(p2.gd %>% select(where(is.factor)), unique) %>% as.data.frame() %>% arrange()
```

### viz: distribution of level counts
```{r fig.width=12, fig.height=9}
jpal = colorRampPalette(brewer.pal(8,'Dark2'))(22)

p2.gd %>% count(inverter) %>% plot_ly(y = ~fct_reorder(inverter,n), x = ~n, color = ~inverter, colors = jpal) %>% add_bars(hoverinfo = 'text', text = ~n) %>% hide_legend() %>% layout(
    title = 'Source Key Counts',
    xaxis = list(title = ''),
    yaxis = list(title = '')
    ) 
```

<h style="color: blue; font-size:12px;">Sanity Check - PASS - Pretty much a uniform distribution</h>

## EDA: Numeric Vars

### viz bivariate numeric distribution

```{r fig.width=12, fig.height=9}
DataExplorer::plot_boxplot(p2.gd %>% select(where(is.numeric)), by = 'daily_yield')
DataExplorer::plot_boxplot(p2.gd %>% select(where(is.numeric)), by = 'total_yield')
```

### viz: numeric univariate distributions
```{r fig.width=12, fig.height=9}
names.numeric = p2.gd %>% select(where(is.numeric)) %>% names

p2.gd %>% dlookr::plot_normality(
  names.numeric[1],
  names.numeric[2],
  names.numeric[3],
  names.numeric[4]
  )
```

<h style="color: red; font-size:12px;">Seems to be many outliers, especially 0s, in several features.  Indicative of faulty inverters?  Plot by inverter</h>

### viz: numeric univariate distributions
```{r fig.width=12, fig.height=9}
DataExplorer::plot_density(p2.gd %>% select(where(is.numeric)))
```

### viz: distributions by 'inverter' factor
```{r fig.width=12, fig.height=9}
p2.gd %>% mutate(inverter = fct_reorder(.f = inverter, .x = total_yield, .fun = median, .desc = TRUE)) %>%
  plot_ly(y = ~inverter, x = ~total_yield, color = ~inverter, colors = jpal) %>% add_boxplot()%>%
  hide_legend() %>% layout(xaxis = list(title = ''), yaxis = list(title = ''), title = 'Distribution of Total Yield by Inverter')

p2.gd %>% mutate(inverter = fct_reorder(.f = inverter, .x = daily_yield, .fun = median, .desc = TRUE)) %>%
  plot_ly(y = ~inverter, x = ~daily_yield, color = ~inverter, colors = jpal) %>% add_boxplot()%>%
  hide_legend() %>% layout(xaxis = list(title = ''), yaxis = list(title = ''), title = 'Distribution of Daily Yield by Inverter')

p2.gd %>% mutate(inverter = fct_reorder(.f = inverter, .x = ac_power, .fun = median, .desc = TRUE)) %>%
  plot_ly(y = ~inverter, x = ~ac_power, color = ~inverter, colors = jpal) %>% add_boxplot()%>%
  hide_legend() %>% layout(xaxis = list(title = ''), yaxis = list(title = ''), title = 'Distribution of AC Power by Inverter')

p2.gd %>% mutate(inverter = fct_reorder(.f = inverter, .x = dc_power, .fun = median, .desc = TRUE)) %>%
  plot_ly(y = ~inverter, x = ~dc_power, color = ~inverter, colors = jpal) %>% add_boxplot()%>%
  hide_legend() %>% layout(xaxis = list(title = ''), yaxis = list(title = ''), title = 'Distribution of DC Power by Inverter')
```

### correlations: viz
```{r fig.width=12, fig.height=9}
p2.gd %>% dlookr::plot_correlate()
```

<h style="color: blue; font-size:12px;">since dc and ac power are just perfectly convertible (like fahrenheit and celsius), they have a perfect correlation</h>

## EDA: Time Series Viz

## Anomoly Plot
```{r fig.width=15, fig.height= 12, warning=FALSE, message=FALSE}
library(scales)
library(anomalize)
# anomalize(data, target, method = c("iqr", "gesd"), alpha = 0.05, max_anoms = 0.2, verbose = FALSE)

# alpha: Controls the width of the "normal" range. Lower values are more conservative while higher values are less prone to incorrectly classifying "normal" observations.
# max_anoms: The maximum percent of anomalies permitted to be identified.

p2.gd.anomalize = p2.gd %>% arrange(date_time) %>% 
  mutate(inverter = fct_reorder(inverter, -daily_yield)) %>% 
  group_by(inverter) %>%
  time_decompose(daily_yield, method = 'twitter', merge = TRUE) %>%
  anomalize(remainder, alpha = 0.05, method = 'gesd') %>%
  time_recompose()

ggplotly(
  p2.gd.anomalize %>%
    plot_anomalies(
      ncol = 2,
      alpha_dots = 0.5,
      alpha_circles = 0.5,
      size_circles = 2,
      time_recomposed = TRUE,
      alpha_ribbon = 0.05
      ) + scale_y_continuous(labels = comma) +
    labs(x = '', y = 'daily yield')
  ) %>% layout(showlegend = FALSE)
```


# Notes

1. better Total Yield viz to show incremental change -- maybe diff?